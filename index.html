<!-- Add algorithm. Make function creation better -->
<!-- Add CSS for combining it all -->


<!-- 1. Make it one input function bar 2. Add levels 3. figure out how to get rid
of the extra input bars 4.-->

<!-- https://stackoverflow.com/questions/13152578/create-a-draggable-div-in-native-javascript -->

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Chain Rule</title>
    <link href="style.css" type="text/css" rel="stylesheet">
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js">
        MathJax.Hub.Config({
            extensions: ["tex2jax.js"],
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [['$', '$'], ["\\(", "\\)"]],
                displayMath: [['$$', '$$'], ["\\[", "\\]"]],
            },
            "HTML-CSS": { availableFonts: ["TeX"] }
        });
    </script>

  </head>
  <body>
    <header>
        <h1>
          Multivariate Chain Rule
        </h1>
        <h3>By Sam Xifaras and Malcolm Essaid</h3>
    </header>
      <div id="derivative">
          $$\nabla F(x,y) = \Big \langle \frac{\partial F}{\partial x}, \frac{\partial F}{\partial y} \Big \rangle$$
      </div>
      <div id = "container">
    <div class = "sideBars" id = "leftside">
      <h5>Functions:</h5>
    </div>
    <aside class = "sideBars" id="rightside">
      <input type="text" name="VarCreate" value="Type a Function" id = "masterInput"><br>
      <input type="text" name="VarIdentifier" value="Define the Variables" id = 'masterVar'><br>
      <button type="button" name="button" id = "masterCreate">Create</button> <br>
      <button type="button" name="button" id = 'clear'>Clear</button><br>
    </aside>
    </div>

    <script src="mathhelper.js" type="text/javascript"></script>
      <script type="text/javascript">


    function getArrowPoints(x0, y0, x1, y1) {
        d = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
        r = 20;
        t = 1 - ((r * Math.sqrt(3)) / (2 * d));
        D = [x0 * (1 - t) + x1 * t, y0 * (1 - t) + y1 * t];
        m = -(x1 - x0) / (y1 - y0);
        Ax = (r / (2 * Math.sqrt(1 + Math.pow(m, 2)))) + D[0];
        negAx = (-r / (2 * Math.sqrt(1 + Math.pow(m, 2)))) + D[0];
        Ay = function (x) { return m * (x - D[0]) + D[1]; };
        
        points = [[x1, y1], [Ax, Ay(Ax)], [negAx, Ay(negAx)]];

        return points[0][0] + "," + points[0][1] + " " + points[1][0] + "," + points[1][1] + " " + points[2][0] + "," + points[2][1];
    }

    var functionSet = [];
    var valuesNaught = 0;

    var functionTree = null;

    var dragObj = null;

    var lineSrc = null;
    var line = null;
    var lines = [];
    var defaultRadius = 40;

    var adjacencyMatrix = [];

    const width = 750,
          height = 400,
          margin = {
              top: 10,
              bottom: 100,
              left: 100,
              right: 10,
          };

    var svg = d3.select("#container").append("svg")
        .attr("width", width)
        .attr("height", height)
        .style("margin", "0 auto")
        .style("display", "block")
        .style("overflow", "visible")
        .on("mouseup", function (d) {

            if (line != null) {
                var coordinates = [0, 0];
                coordinates = d3.mouse(this);
                var x = coordinates[0];
                var y = coordinates[1];

                var minDistance = null;
                var target = null;
                var c = circles.selectAll("g")
                  .each(function (d) {
                      var elem = d3.select(this);
                      console.log("PROCESSING");

                      console.log(elem.node() + "," + lineSrc.node());
                      if (!elem.node().isEqualNode(lineSrc.node())) {
                          var distance = Math.sqrt(Math.pow(x - elem.attr("ix"), 2) + Math.pow(y - elem.attr("iy"), 2));
                          if (minDistance == null || distance < minDistance) {
                              minDistance = distance;
                              target = elem;
                          }
                      }
                      else {
                          console.log("EQUAL");
                      }
                  });

                if (minDistance == null) line.remove();

                console.log(lines);
                var hasParent = false;
                lines.forEach(function (d) {
                    if (d.target.node().isEqualNode(target.node())) {
                        hasParent = true;
                    }
                });
                console.log(hasParent);

                // If line is not targetted or target and source are already connected, remove
                if (hasParent || target == null || minDistance > defaultRadius) {
                    line.remove();
                }
                else {
                    line.select("line").attr("x2", target.attr("ix"))
                      .attr("y2", target.attr("iy"));
                    var x1 = line.select("line").attr("x1");
                    var y1 = line.select("line").attr("y1");
                    var x2 = line.select("line").attr("x2");
                    var y2 = line.select("line").attr("y2");
                    line.select(".arrowhead")
                        .attr("points", getArrowPoints(+x1, +y1, +x2, +y2));

                    lines.push({
                        "line": line,
                        "source": lineSrc,
                        "target": target
                    });
                }
            }

            dragObj = null;
            line = null;
            lineSrc = null;
        })
          .on("mousemove", function (d) {
              var coordinates = [0, 0];
              coordinates = d3.mouse(this);
              var x = coordinates[0];
              var y = coordinates[1];

              if (dragObj == null && line == null)
                  return;
              else if (dragObj != null) {
                  dragObj.attr("transform", "translate(" + x + "," + y + ")")
                      .attr("ix", x)
                      .attr("iy", y);

                  // TODO: Update lines connected to dragObj
                  for (var i = 0; i < lines.length; i++) {
                      if (dragObj.node().isEqualNode(lines[i].source.node())) {
                          var x2 = lines[i].line.select("line").attr("x2");
                          var y2 = lines[i].line.select("line").attr("y2");
                          lines[i].line.select("line").attr("x1", x).attr("y1", y);
                          lines[i].line.select(".arrowhead").attr("points", getArrowPoints(+x, +y, +x2, +y2));
                      }
                      else if (dragObj.node().isEqualNode(lines[i].target.node())) {
                          var x1 = lines[i].line.select("line").attr("x1");
                          var y1 = lines[i].line.select("line").attr("y1");
                          lines[i].line.select("line").attr("x2", x).attr("y2", y);
                          lines[i].line.select(".arrowhead").attr("points", getArrowPoints(+x1, +y1, +x, +y));
                      }
                  }
              }
              else if (line != null) {
                  line.select("line").attr("x2", x).attr("y2", y);
                  var x1 = line.select("line").attr("x1");
                  var y1 = line.select("line").attr("y1");
                  line.select(".arrowhead")
                    .attr("points", getArrowPoints(+x1, +y1, +x, +y));
              }
          })
        .on("contextmenu", function (d) {
            d3.event.preventDefault();
        });

    var circles = svg.append("g");
    var linesg = svg.append("g");

    document.getElementById('clear').addEventListener('click', function () {
        svg.selectAll('circle')
          .remove();
        svg.selectAll('text')
          .remove()
        d3.selectAll(".subFunction").remove();
        d3.selectAll(".listFunction").remove();
        document.getElementById('functDisplay').innerHTML = '';
        document.getElementById('bar').value = 'Number of Inputs';

    })

    document.getElementById('masterInput').addEventListener('click', function () {
        document.getElementById('masterInput').value = "";
    })
    document.getElementById('masterVar').addEventListener('click', function () {
        document.getElementById('masterVar').value = "";
    })
    document.getElementById('masterCreate').addEventListener('click', function () {
        logText('masterInput', 'masterVar', true);
        createFunction();
        listFunct(false);
    })

    function listFunct(returnFunct) {
        var x = document.createElement('p');
        var y = document.getElementById('masterInput').value;
        if (y === "Type a Function") {
            return;
        }
        x.innerHTML = y;
        x.style.margin = 0;
        x.className = "listFunction"
        document.getElementById('leftside').appendChild(x)
        document.getElementById('masterInput').value = "Type a Function";
        document.getElementById('masterVar').value = 'Define the Variables';
        if (returnFunct) {
            return x;
        }
    }


    // Logs data. Sets up 2 different points for each data point

    // Adds parent and children to Datum when
    function logText(id1, id2, doPush) {
        var text = document.getElementById(id1).value;
        var vars = document.getElementById(id2).value;
        var varSet = vars.split(',');

        if (text === "Type a Function") {
            return null;
        }
        if (doPush) {
            var datum = [];
            datum.push(text)
            datum.push(varSet)
            functionSet.push(datum)
            console.log(JSON.stringify(functionSet))
        }
        else {
            return (text)
        }
    }

    function createFunction() {
        var group = circles.selectAll("g")
          .data(functionSet)
          .enter()
          .append("g")
          .attr("transform", "translate(" + width / 2 + "," + height / 8 + ")")
          .attr("ix", width / 2)
          .attr("iy", height / 8)
          .on("mousedown", function (d) {
              if (d3.event.button == 0) {
                  line = null;
                  dragObj = d3.select(this);
              }
              else {
                  // Make sure dragObj is null
                  dragObj = null;

                  var elem = d3.select(this);

                  // add line drawing mechanic
                  var coordinates = [0, 0];
                  coordinates = d3.mouse(this);
                  var x = coordinates[0];
                  var y = coordinates[1];

                  line = linesg.append("g");

                  line.append("line")
                      .attr("x1", elem.attr("ix"))
                      .attr("x2", x)
                      .attr("y1", elem.attr("iy"))
                      .attr("y2", y)
                      .attr("stroke-width", 4)
                      .attr("stroke", "black");

                 var triangle = line.append("polygon")
                     .classed("arrowhead", true)
                    .attr("points", getArrowPoints(+elem.attr("ix"), +elem.attr("iy"), +x, +y))
                    .attr("fill", "black");
                  //.classed("line-draggable", true);
                  lineSrc = elem;
              }

          });
        group.append("circle")
          .style('fill', "#e0e0e0")
          .attr('r', defaultRadius)
          .attr("cx", 0)
          .attr("cy", 0)
        group.append("text")
          .attr("x", 0)
          .attr("y", -10)
          .attr("text-anchor", "middle")
          .text(function (d) {
              return d[0];
          });
    }

      </script>
  </body>

</html>

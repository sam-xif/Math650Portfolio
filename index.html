<!-- Add algorithm. Make function creation better -->
<!-- Add CSS for combining it all -->


<!-- 1. Make it one input function bar 2. Add levels 3. figure out how to get rid
of the extra input bars 4.-->

<!-- https://stackoverflow.com/questions/13152578/create-a-draggable-div-in-native-javascript -->

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Chain Rule</title>
    <link href="style.css" type="text/css" rel="stylesheet">
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js">
        MathJax.Hub.Config({
            extensions: ["tex2jax.js"],
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [['$', '$'], ["\\(", "\\)"]],
                displayMath: [['$$', '$$'], ["\\[", "\\]"]],
            },
            "HTML-CSS": { availableFonts: ["TeX"] }
        });
    </script>

  </head>
  <body>
    <header>
        <h1>
          Multivariate Chain Rule
        </h1>
        <h3>By Sam Xifaras and Malcolm Essaid</h3>
    </header>
      <div id="derivative">
          $$\nabla F(x,y) = \Big \langle \frac{\partial F}{\partial x}, \frac{\partial F}{\partial y} \Big \rangle$$
      </div>
      <div id = "container">
    <div class = "sideBars" id = "leftside">
      <h5>Functions:</h5>
    </div>
    <aside class = "sideBars" id="rightside">
      <input type="text" name="VarCreate" value="Type a Function" id = "masterInput"><br>
      <input type="text" name="VarIdentifier" value="Define the Variables" id = 'masterVar'><br>
      <button type="button" name="button" id = "masterCreate">Create</button> <br>
      <button type="button" name="button" id = 'clear'>Clear</button><br>
    </aside>
    </div>

    <script src="mathhelper.js"></script>
  </body>
  <script>


  var functionSet = [];
  var valuesNaught = 0;

  var dragObj = null;

  var lineSrc = null;
      var line = null;
      var lines = [];
      var defaultRadius = 15;

      var adjacencyMatrix = [];

  const width = 750,
        height = 400,
        margin = {
            top: 10,
            bottom: 100,
            left: 100,
            right: 10,
        };

  var svg = d3.select("#container").append("svg")
      .attr("width", width)
      .attr("height", height)
      .style("margin", "0 auto")
      .style("display", "block")
      .style("overflow", "visible")
      .on("mouseup", function (d) {

          if (line != null) {
              var coordinates = [0, 0];
              coordinates = d3.mouse(this);
              var x = coordinates[0];
              var y = coordinates[1];

              var minDistance = null;
              var target = null;
              var c = circles.selectAll("g")
                .each(function (d) {
                    var elem = d3.select(this);
                    console.log("PROCESSING");

                    console.log(elem.node() +  "," + lineSrc.node());
                    if (!elem.node().isEqualNode(lineSrc.node())) {
                        var distance = Math.sqrt(Math.pow(x - elem.attr("ix"), 2) + Math.pow(y - elem.attr("iy"), 2));
                        if (minDistance == null || distance < minDistance) {
                            minDistance = distance;
                            target = elem;
                        }
                    }
                    else {
                        console.log("EQUAL");
                    }
                });

              console.log(minDistance);
              // If line is not targetted or target and source are already connected, remove
              if (minDistance > defaultRadius) {
                  line.remove();
              }
              else {
                  line.attr("x2", target.attr("ix"))
                    .attr("y2", target.attr("iy"));

                  lines.push({
                      "line": line,
                      "source": lineSrc,
                      "target": target
                  });
              }


          }

          dragObj = null;
          line = null;
          lineSrc = null;
      })
        .on("mousemove", function (d) {
            var coordinates = [0, 0];
            coordinates = d3.mouse(this);
            var x = coordinates[0];
            var y = coordinates[1];

            if (dragObj == null && line == null)
                return;
            else if (dragObj != null) {
                dragObj.attr("transform", "translate(" + x + "," + y + ")")
                    .attr("ix", x)
                    .attr("iy", y);

                // TODO: Update lines connected to dragObj
                for (var i = 0; i < lines.length; i++) {
                    if (dragObj.node().isEqualNode(lines[i].source.node())) {
                        lines[i].line.attr("x1", x);
                        lines[i].line.attr("y1", y);
                    }
                    else if (dragObj.node().isEqualNode(lines[i].target.node())) {
                        lines[i].line.attr("x2", x);
                        lines[i].line.attr("y2", y);
                    }
                }

            }
            else if (line != null) {
                line.attr("x2", x).attr("y2", y);
            }
        })
      .on("contextmenu", function (d) {
          d3.event.preventDefault();
      });

  var circles = svg.append("g");
  var linesg = svg.append("g");

  document.getElementById('clear').addEventListener('click', function(){
    svg.selectAll('circle')
      .remove();
    svg.selectAll('text')
      .remove()
    d3.selectAll(".subFunction").remove();
    d3.selectAll(".listFunction").remove();
    document.getElementById('functDisplay').innerHTML = '';
    document.getElementById('bar').value = 'Number of Inputs';

  })

  document.getElementById('masterInput').addEventListener('click', function(){
    document.getElementById('masterInput').value = "";
  })
  document.getElementById('masterVar').addEventListener('click', function(){
    document.getElementById('masterVar').value = "";
  })
  document.getElementById('masterCreate').addEventListener('click', function(){
    logText('masterInput', 'masterVar',true);
    createFunction();
    listFunct(false);
    console.log(JSON.stringify(functionSet))
  })

  function listFunct(returnFunct){
    var x = document.createElement('p');
    var y = document.getElementById('masterInput').value;
    if (y === "Type a Function"){
      return;
    }
    x.innerHTML = y;
    x.style.margin = 0;
    x.className = "listFunction"
    document.getElementById('leftside').appendChild(x)
    document.getElementById('masterInput').value = "Type a Function";
    document.getElementById('masterVar').value = 'Define the Variables';
    if (returnFunct){
      return x;
    }
  }


// Logs data. Sets up 2 different points for each data point
  function logText(id1, id2, doPush){
    var text = document.getElementById(id1).value;
    var vars =  document.getElementById(id2).value;
    var varSet = vars.split(',');

    if (text === "Type a Function"){
      return null;
    }
    if (doPush){
      var datum = [];
      datum.push(text)
      datum.push(varSet)
      functionSet.push(datum)
      console.log(JSON.stringify(functionSet))
    }
    else {
      return (text)
    }
  }

  function createFunction() {
      // Number of circles
      // var matrix_size = functionSet.length;
      // for (var i = 0; i < matrix_size; i++) {
      //     var subArray = []
      //     for (var j = 0; j < matrix_size; j++) {
      //         subArray.push(0);
      //     }
      //     adjacencyMatrix.push(subArray);
      // }

      var group = circles.selectAll("g")
        .data(functionSet)
        .enter()
        .append("g")
        .attr("transform", "translate(" + width/2 + "," + height/8 + ")")
        .attr("ix", 100)
        .attr("iy", 100)
        .on("mousedown", function (d) {
            if (d3.event.button == 0) {
                line = null;
                dragObj = d3.select(this);
            }
            else {
                // Make sure dragObj is null
                dragObj = null;

                var elem = d3.select(this);

                // add line drawing mechanic
                var coordinates = [0, 0];
                coordinates = d3.mouse(this);
                var x = coordinates[0];
                var y = coordinates[1];

                line = linesg.append("line")
                    .attr("x1", elem.attr("ix"))
                    .attr("x2", x)
                    .attr("y1", elem.attr("iy"))
                    .attr("y2", y)
                    .attr("stroke-width", 4)
                    .attr("stroke", "black");
                //.classed("line-draggable", true);

                lineSrc = elem;
            }

        });
      group.append("circle")
        .style('fill', "#e0e0e0")
        .attr('r', defaultRadius)
        .attr("cx", 0)
        .attr("cy", 0)
      group.append("text")
        .attr("x", 0)
        .attr("y", -10)
        .attr("text-anchor", "middle")
        .text(function (d) {
            return d[0];
        });
  }

  </script>

</html>

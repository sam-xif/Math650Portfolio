<!-- Add algorithm. Make function creation better -->
<!-- Add CSS for combining it all -->


<!-- 1. Make it one input function bar 2. Add levels 3. figure out how to get rid
of the extra input bars 4.-->

<!-- https://stackoverflow.com/questions/13152578/create-a-draggable-div-in-native-javascript -->

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Chain Rule</title>
    <link href="style.css" type="text/css" rel="stylesheet">
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js">
        MathJax.Hub.Config({
            extensions: ["tex2jax.js"],
            jax: ["input/TeX", "output/HTML-CSS"],
            tex2jax: {
                inlineMath: [['$', '$'], ["\\(", "\\)"]],
                displayMath: [['$$', '$$'], ["\\[", "\\]"]],
            },
            "HTML-CSS": { availableFonts: ["TeX"] }
        });
    </script>

  </head>
  <body>
    <header>
      <div id = "subHeader">
        <h1>
          Multivariate Chain Rule
        </h1>
        <h3>By Sam Xifaras and Malcolm Essaid</h3>
        </div>
        <div id="derivative">
            $$\nabla F(x,y) = \Big \langle \frac{\partial F}{\partial x}, \frac{\partial F}{\partial y} \Big \rangle$$
        </div>

    </header>

      <div id="body-content">
      <table id = "table">
         <tr>
           <th>Variable:</th>
           <th>Function:</th>
         </tr>
      </table>
      <div id = "container">
    </div>
  </div>

    <script src="mathhelper.js"></script>
  </body>
  <script>


  var functionSet = [];
  var valuesNaught = 0;

  var dragObj = null;

  var lineSrc = null;
      var line = null;
      var lines = [];
      var defaultRadius = 40;

      var adjacencyMatrix = [];

  function createTable(n){
    for (var i = 0; i < n; i++) {
      var temp1 = document.createElement('tr');
      var temp2 = document.createElement('td');
      var temp3 = document.createElement('td');
      var temp4 = document.createElement('input');
      temp4.type = 'text';
      temp4.placeholder = 'x';

      var temp5 = document.createElement('input');
      temp5.type = 'text';
      temp5.placeholder = 'F(x)';

      temp2.className = 'var';
      temp2.id = 'var' + i;

      temp3.className = 'fun';
      temp3.id = 'fun' + i;

      temp2.appendChild(temp4);
      temp3.appendChild(temp5);
      temp1.appendChild(temp2);
      temp1.appendChild(temp3);

      document.getElementById('table').appendChild(temp1);
    }
  }

  function addEventToVar(){
    var varSet = document.getElementsByClassName('var');
    for (var i = 0; i < varSet.length; i++) {
      varSet[i].addEventListener('keyup', function(){
        var val = d3.select(this).attr('id').substring(3);
        logText(('fun'+val), ('var'+val), true, val);
        createFunction();
        this.removeEventListener('keyup', arguments.callee);
      })
    }
  }
  function addSecondEventToVar(){
    var varSet = document.getElementsByClassName('var');
    for (var i = 0; i < varSet.length; i++) {
      varSet[i].addEventListener('keyup', function(){
          var val = d3.select(this).attr('id').substring(3);
        updateVarOfFunction(logText(('fun' + val),('var'+val), false, val, true), val);
      })
    }
  }
  function addEventToFun() {
    var funSet = document.getElementsByClassName('fun');
    for (var i = 0; i < funSet.length; i++) {
      funSet[i].addEventListener('keyup', function(){
        var val = d3.select(this).attr('id').substring(3);
       updateTextOfFunction(logText(('fun' + val),('var'+val), false, val, false), val);
      })
    }
  }
  function updateVarOfFunction(variable, val) {
    functionSet[val][1] = variable;
    console.log(JSON.stringify(functionSet))

  }
  function updateTextOfFunction(text, val) {

    functionSet[val][0] = text;
    console.log(JSON.stringify(functionSet))
    circles.selectAll('g')
      .data(functionSet)
      .select("text")
      .text(function (d) {
          return d[0];
      });


    // var index = functionSet.findIndex(function(d) {return d[2] === val)

  }

  var svg = d3.select("#container").append("svg")
      .attr("height", '100%')
      .style("margin", "0 auto")
      .style("display", "block")
      .style("overflow", "visible")
      .on("mouseup", function (d) {

          if (line != null) {
              var coordinates = [0, 0];
              coordinates = d3.mouse(this);
              var x = coordinates[0];
              var y = coordinates[1];

              var minDistance = null;
              var target = null;
              var c = circles.selectAll("g")
                .each(function (d) {
                    var elem = d3.select(this);
                    console.log("PROCESSING");

                    console.log(elem.node() +  "," + lineSrc.node());
                    if (!elem.node().isEqualNode(lineSrc.node())) {
                        var distance = Math.sqrt(Math.pow(x - elem.attr("ix"), 2) + Math.pow(y - elem.attr("iy"), 2));
                        if (minDistance == null || distance < minDistance) {
                            minDistance = distance;
                            target = elem;
                        }
                    }
                    else {
                        console.log("EQUAL");
                    }
                });

              if (minDistance == null) line.remove();

              console.log(minDistance);
              // If line is not targetted or target and source are already connected, remove
              if (minDistance > defaultRadius) {
                  line.remove();
              }
              else {
                  line.attr("x2", target.attr("ix"))
                    .attr("y2", target.attr("iy"));

                  lines.push({
                      "line": line,
                      "source": lineSrc,
                      "target": target
                  });
              }


          }

          dragObj = null;
          line = null;
          lineSrc = null;
      })
        .on("mousemove", function (d) {
            var coordinates = [0, 0];
            coordinates = d3.mouse(this);
            var x = coordinates[0];
            var y = coordinates[1];

            if (dragObj == null && line == null)
                return;
            else if (dragObj != null) {
                dragObj.attr("transform", "translate(" + x + "," + y + ")")
                    .attr("ix", x)
                    .attr("iy", y);

                // TODO: Update lines connected to dragObj
                for (var i = 0; i < lines.length; i++) {
                    if (dragObj.node().isEqualNode(lines[i].source.node())) {
                        lines[i].line.attr("x1", x);
                        lines[i].line.attr("y1", y);
                    }
                    else if (dragObj.node().isEqualNode(lines[i].target.node())) {
                        lines[i].line.attr("x2", x);
                        lines[i].line.attr("y2", y);
                    }
                }

            }
            else if (line != null) {
                line.attr("x2", x).attr("y2", y);
            }
        })
      .on("contextmenu", function (d) {
          d3.event.preventDefault();
      });




  var circles = svg.append("g");
  var linesg = svg.append("g");


// Adds parent and children to Datum when
  function logText(id1, id2, doPush, index, varBoolean){
    var text = document.getElementById(id1).children[0].value;
    var vars =  document.getElementById(id2).children[0].value;
    var varSet = vars.split(',');

    if (text === "Type a Function"){
      return null;
    }
    if (doPush){
      var datum = [];
      datum.push(text)
      datum.push(varSet)
      datum.push(index)
      functionSet.push(datum)
      //console.log(JSON.stringify(functionSet))
    }
    if (varBoolean){
      return varSet
    }
    else {
      return (text)
    }
  }

  function createFunction() {

    // Need to create definite height/width
    var width = document.getElementById('container').width;
    var height = document.getElementById('container').height;
      var group = circles.selectAll("g")
        .data(functionSet)
        .enter()
        .append("g")
        .attr("transform", "translate(" + 100/2 + "," + 800/8 + ")")
        .attr("ix", width / 2)
        .attr("iy", height / 8)
        .on("mousedown", function (d) {
            if (d3.event.button == 0) {
                line = null;
                dragObj = d3.select(this);
            }
            else {
                // Make sure dragObj is null
                dragObj = null;

                var elem = d3.select(this);

                // add line drawing mechanic
                var coordinates = [0, 0];
                coordinates = d3.mouse(this);
                var x = coordinates[0];
                var y = coordinates[1];

                line = linesg.append("line")
                    .attr("x1", elem.attr("ix"))
                    .attr("x2", x)
                    .attr("y1", elem.attr("iy"))
                    .attr("y2", y)
                    .attr("stroke-width", 4)
                    .attr("stroke", "black");
                //.classed("line-draggable", true);
                lineSrc = elem;
            }

        });
      group.append("circle")
        .style('fill', "#e0e0e0")
        .attr('r', defaultRadius)
        .attr("cx", 0)
        .attr("cy", 0)
        .attr('id', function(d, i){return 'p' + d[2]})
      group.append("text")
        .attr("x", 0)
        .attr("y", -10)
        .attr("text-anchor", "middle")
        .text(function (d) {
            return d[0];
        });


  }
  createTable(12);
  addEventToVar();
  addEventToFun();
  addSecondEventToVar();

  </script>

</html>
